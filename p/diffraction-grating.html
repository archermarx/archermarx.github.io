<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Diffraction simulation</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="..//assets/css/style.css" />
  <link rel="icon" type="image/x-icon" href=/favicon.ico/>
</head>
<body>
<div class="navbar">
<p><a href="/index.html">Home</a> | <a
href="/publications.html">Publications</a> | <a
href="/archive.html">Posts</a> | <a
href="/files/thomas_marks_cv_2024.pdf">Curriculum Vitae</a></p>
</div>
<h1 id="diffraction-grating-simulation">Diffraction grating
simulation</h1>
<p>Below is a simulation of a linearly-polarized point wave emanating
from a point passing through a diffraction grating. You can vary several
parameters to see how the interference pattern on the other end of the
grating changes.</p>
<div class="centered-block">
<div class="controls">
<fieldset>
    <legend><b>Source</b></legend>
    <div>
        <label for="sourcedist_input">Distance: <output id="sourcedist_output"/></label>
        <input type="range" id="sourcedist_input" min="0.15" max="8" value="2.5" step="any" autocomplete="off"/>
    </div>
    <div>
        <label for="wavenumber_input">Wavenumber: <output id="wavenumber_output"/></label>
        <input type="range" id="wavenumber_input" min="1" max="64" value="8" step="any" autocomplete="off"/>
    </div>
</fieldset>
<fieldset>
    <legend><b>Grating</b></legend>
    <div>
        <label for="numslits_input">Slits: <output id="numslits_output"/></label>
        <input type="range" id="numslits_input" min="2" max="16" value="3" step="1" autocomplete="off"/>
    </div>
    <div>
        <label for="slitwidth_input">Slit width</label>
        <input type="range" id="slitwidth_input" min="0.02" max="0.95" value="0.5" step="any" autocomplete="off"/>
    </div>
    <div>
        <label for="spacing_input">Spacing</label>
        <input type="range" id="spacing_input" min="0" max="1" value="0.5" step="any" autocomplete="off"/>
    </div>
    <div>
        <label for="position_input">Position: <output id="position_output"/></label>
        <input type="range" id="position_input" min="-0.5" max="0.0" value="-0.3" step="any" autocomplete="off"/>
    </div>
</fieldset>
<fieldset>
    <legend><b>Other</b></legend>
    <div>
        <label for="rays_input">Rays/slit/pixel: <output id="rays_output"/></label>
        <input type="range" id="rays_input" min="1" max="25" value="10" step="1" autocomplete="off"/>
    </div>
    <div>
        <label for="use_brightness_input">Show intensity</label>
        <input type="checkbox" id="use_brightness_input" value = "use_brightness" autocomplete="off"/>
    </div>
    <div>
        <label for="brightness_input">Brightness</label>
        <input type="range" id="brightness_input" min="1.0" max="5.0" value="1.0" step="any" autocomplete="off"/>
    </div>
</fieldset>
</div>
<canvas id="canvas" width=1000 height=1200></canvas>
</div>
<script src = "../scripts/webgl.js"></script>
<script>
// Get the webgl rendering context
var gl = canvas.getContext('webgl');


// vertex shader
var vshader = `
attribute vec4 position;
void main() {
    gl_Position = position;
}
`;

// fragment shader
var fshader = `
precision highp float;

uniform float width;
uniform float height;
#define PI 3.141592653589
float timefreq = 100.0;
uniform float time;

#define RED vec3(162., 30., 37.) / 256.0
#define BLUE vec3(11., 102., 188.) / 256.0
#define WHITE vec3(1.0, 1.0, 1.0)
#define BLACK vec3(0.0, 0.0, 0.0)

#define MIN_DIST 0.0125
#define BLUR_RADIUS 1.05
#define SLIT_HEIGHT 0.02

#define MAX_SLITS 16
float centers[MAX_SLITS];

uniform float grating_y;
uniform int num_slits;
uniform float spacing;
uniform float slit_width;
uniform float wavenumber;
uniform float source_distance;
uniform bool use_brightness;
uniform float brightness;

#define MAX_RAYS 200
uniform int num_rays;

float wave_amplitude(vec2 pos, vec2 sourcePos, float t) {
    float r = distance(pos, sourcePos) / width;
    return sin(t - 2.0*PI * wavenumber * r);
}

float cast_rays(vec2 pos, vec2 sourcePos) {
    float x = pos.x;
    float y = pos.y;
    float w = 0.5 * slit_width * spacing / float(num_slits - 1); 
    float dy = y - grating_y*height;

    float amplitude = 0.0;

    // iterate over slits
    float num_hits = 0.0;
    float total_angle = 0.0;

    for (int i = 0; i < MAX_SLITS; i++) {
        if (i >= num_slits) {break;}
        
        float dx_min = pos.x - (centers[i] - w) * width;
        float dx_max = pos.x - (centers[i] + w) * width;
        float theta_min = atan(dy, -dx_max);
        float theta_max = atan(dy, -dx_min);
        float angle_frac = theta_max - theta_min;
        total_angle += angle_frac;
        float dtheta = angle_frac / float(num_rays);

        for (int i = 0; i < MAX_RAYS; i++) {
            if (i >= num_rays) {break;}
            float theta = theta_min + (float(i)+0.5) * dtheta;
            // check here for sign convention
            vec2 ray = vec2(cos(theta), sin(theta));

            // find intercept location 
            float t = dy / ray.y;
            float ix = (pos.x + ray.x*t)/width;
                
            // Get wave amplitude here
            vec2 rayPos = vec2(ix*width, grating_y*height);
            float dist = distance(rayPos, pos);
            float group_vel = 1.0 / (2.0 * PI * wavenumber / width);
            float time_delay = dist / group_vel;
            float a = wave_amplitude(rayPos, sourcePos, time - time_delay);
            amplitude += a * dtheta;
        }
    }
    
    if (use_brightness) {
        return brightness * amplitude / PI;
    }

    return amplitude / total_angle;
}

vec3 wave_color(float amplitude) {
    vec3 color;
    if (amplitude > 0.0) {
        color = RED;
    } else {
        color = BLUE;
    }
    float s = pow(abs(amplitude), 1.2) * 1.2; // gamma correction and scaling
    s = clamp(s, 0.0, 1.0); // clamp to [0,1]
    color *= s;
    return color;
}

vec3 draw_grate(vec3 base, vec2 pos) {
    float x = pos.x / width;
    float y = pos.y / height;
    float w = 0.5 * slit_width * spacing / float(num_slits - 1); 
    float grating_thickness = 0.01;

    if (y < (grating_y - grating_thickness / 2.0) ||
        y > (grating_y + grating_thickness / 2.0)) {
        return base;
    }

    for (int i = 0; i <= MAX_SLITS; i++) {
        if (i >= num_slits) {break;}
        if (x >= centers[i] - w && x <= centers[i] + w) {
            return base;
        }  
    }
    return WHITE;
}

vec3 draw_base(vec2 pos, vec2 sourcePos) {
    float x = pos.x / width;
    float y = pos.y / height;

    // draw region downstream of grating
    if (y > grating_y) {
        return wave_color(cast_rays(pos, sourcePos));
    }

    vec3 color = wave_color(wave_amplitude(pos, sourcePos, time));
    return color;
}

void main () {
    // determine grate centers
    if (num_slits == 1) {
        centers[0] = 0.0;
    } else {
        float increment = spacing / float(num_slits-1);
        for (int i = 0; i < MAX_SLITS; i++) {
            if (i >= num_slits) {break;}
            centers[i] = -0.5 * spacing + float(i)*increment;
        }
    }

    vec2 pos = gl_FragCoord.xy - vec2(width/2.0, height/2.0);
    vec2 sourcePos = vec2(0.0, -source_distance * width + grating_y * height);

    vec3 color = draw_grate(draw_base(pos, sourcePos), pos);   
    gl_FragColor = vec4(color, 1.0);
}
`;

// Controls
var time = 0.0;
var dt = 0.1;

// Compile program
var program = compile(gl, vshader, fshader);

// Send canvas size to shader
var width = canvas.width;
var height = canvas.height;
var widthLoc = gl.getUniformLocation(program, 'width');
var heightLoc = gl.getUniformLocation(program, 'height');
var timeLoc = gl.getUniformLocation(program, 'time');
gl.uniform1f(widthLoc, width);
gl.uniform1f(heightLoc, height);

// Set controls
var spacing_input = document.querySelector("#spacing_input");
set_spacing = (val) => {
    gl.uniform1f(gl.getUniformLocation(program, 'spacing'), val);
}
spacing_input.addEventListener("input", (event) => {set_spacing(event.target.value)});

var slitwidth_input = document.querySelector("#slitwidth_input");
set_slitwidth = (val) => {
    gl.uniform1f(gl.getUniformLocation(program, 'slit_width'), val);
}
slitwidth_input.addEventListener("input", (event) => {set_slitwidth(event.target.value)});

var wavenumber_input = document.querySelector("#wavenumber_input");
var wavenumber_output = document.querySelector("#wavenumber_output");
set_wavenumber = (val) => {
    wavenumber_output.textContent = Math.round(10*val)/10;
    gl.uniform1f(gl.getUniformLocation(program, 'wavenumber'), val);
}
wavenumber_input.addEventListener("input", (event) => {set_wavenumber(event.target.value)});

var numslits_input = document.querySelector("#numslits_input");
var numslits_output = document.querySelector("#numslits_output");
set_numslits = (val) => {
    numslits_output.textContent = val;
    gl.uniform1i(gl.getUniformLocation(program, 'num_slits'), val);
}
numslits_input.addEventListener("input", (event) => {set_numslits(event.target.value)});

var sourcedist_input = document.querySelector("#sourcedist_input");
var sourcedist_output = document.querySelector("#sourcedist_output");
set_sourcedist = (val) => {
    sourcedist_output.textContent = Math.round(100*val)/100;
    gl.uniform1f(gl.getUniformLocation(program, 'source_distance'), val);
}
sourcedist_input.addEventListener("input", (event) => {set_sourcedist(event.target.value)});

var rays_input = document.querySelector("#rays_input");
var rays_output = document.querySelector("#rays_output");
set_rays = (val) => {
    rays_output.textContent = val;
    gl.uniform1i(gl.getUniformLocation(program, 'num_rays'), val);
}
rays_input.addEventListener("input", (event) => {set_rays(event.target.value)});

var use_brightness_input = document.querySelector("#use_brightness_input");
set_use_brightness = (val) => {
    gl.uniform1i(gl.getUniformLocation(program, 'use_brightness'), use_brightness_input.checked);
}
use_brightness_input.addEventListener("input", (event) => {set_use_brightness(event.target.value)});

var position_input = document.querySelector("#position_input");
var position_output = document.querySelector("#position_output");
set_position = (val) => {
    position_output.textContent = Math.round(10*val)/10;
    gl.uniform1f(gl.getUniformLocation(program, 'grating_y'), val);
}
position_input.addEventListener("input", (event) => {set_position(event.target.value)});

var brightness_input = document.querySelector("#brightness_input");
set_brightness = (val) => {
    gl.uniform1f(gl.getUniformLocation(program, 'brightness'), val);
}
brightness_input.addEventListener("input", (event) => {set_brightness(event.target.value)});

// initialize controls
set_spacing(spacing_input.value);
set_slitwidth(slitwidth_input.value);
set_wavenumber(wavenumber_input.value);
set_numslits(numslits_input.value);
set_sourcedist(sourcedist_input.value);
set_rays(rays_input.value);
set_position(position_input.value);
set_brightness(brightness_input.value);

// Define vertices and colors
var verticesColors = new Float32Array([
   //x ,  y,    z,  
    -1.0, -1.0, 0.0, 
    -1.0,  1.0, 0.0, 
     1.0,  1.0, 0.0, 
     1.0, -1.0, 0.0,
]);
  
// Save the number of vertices (3)
var n = 4;

// Get the size of each float in bytes (4)
var fsize = verticesColors.BYTES_PER_ELEMENT;
var stride = 3 * fsize;

// Create a buffer object
createBuffer(gl, verticesColors);

// Bind the attribute position to the 1st, 2nd and 3rd floats in every chunk of 6 floats in the buffer
setAttrib(gl, program, 'position', 3, gl.FLOAT, stride, 0);

const interval = setInterval(() => {
    // Set the clear color
    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    // Clear canvas
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Update time and draw
    time += dt;
    gl.uniform1f(timeLoc, time);
    gl.drawArrays(gl.TRIANGLE_FAN, 0, n);
}, 10);

</script>
<p> </p>
<hr />
<p><span class="footer"> *Last updated on Oct 15, 2024. Created using <a
href="https://github.com/eakbas/TSPW">TSPW</a> and <a
href="http://pandoc.org/">pandoc</a>. </span></p>
</body>
</html>
